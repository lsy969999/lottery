/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import {useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { BallCollider, CapsuleCollider, ConeCollider, CylinderCollider, RapierRigidBody, RigidBody } from '@react-three/rapier'

import { button, useControls } from 'leva'
import gsap from 'gsap'

type GLTFResult = GLTF & {
  nodes: {
    BallCatcherGuider1: THREE.Mesh
    BallCatcherGuider2: THREE.Mesh
    ResultCase: THREE.Mesh
    MainSupport: THREE.Mesh
    ResultGuider: THREE.Mesh
    BallCase: THREE.Mesh
    BallInjector3: THREE.Mesh
    BallInjector2: THREE.Mesh
    BallInjecter1: THREE.Mesh
    BallInjector4: THREE.Mesh
    BallInjector5: THREE.Mesh
    BallInjector6: THREE.Mesh
    BallCaseBallInjectorCap: THREE.Mesh
    BallCaseUpperCap: THREE.Mesh
    BallCatcher1: THREE.Mesh
    BallCatcher2: THREE.Mesh
    BallCatcher3: THREE.Mesh
    BallCatcher4: THREE.Mesh
  }
  materials: {}
}

export function Machine(props: JSX.IntrinsicElements['group']) {
  const gltf = useGLTF('models/ballcase2.glb') as GLTFResult
//   const { nodes }= gltf

  return (
    <group {...props} dispose={null} >
      <group >
        <Injectors gltf={ gltf } />
        <BallCase gltf={ gltf } />
        <Catchers gltf={ gltf }/>
        <BallResult gltf={ gltf } />
        <MainSupport gltf={ gltf } />
      </group>
    </group>
  )
}

useGLTF.preload('models/ballcase2.glb')


///
///
///

/** 당첨볼 가이더  */
const Catchers = ({ gltf }: { gltf: GLTFResult }) => {
    const { nodes } = gltf;
    (nodes.BallCatcher1.material as THREE.Material).transparent = true;
    (nodes.BallCatcher1.material as THREE.Material).opacity = 0.1;
    const catcherRef = useRef<RapierRigidBody>(null);

    const [isBallBlock, setIsBallCapBlock] = useState(true)
    const [isWinnerBallExtractor, SetWinnerBallExtractor] = useState(false)
    const upperCapRef = useRef<RapierRigidBody>(null);

    useControls('machaine', {
        isBallCapBlocked: {
            value: true,
            onChange: (value) => {
                if (value)
                    handleBallCapBlock()
                else
                    handleBallCapRelease()
            }
        },
        chatcherRotate: button(()=>handleCatcherRotate()),
        winnerBallExtract: button(()=>handleWinnerBallExtract()),
    })

    /** 볼캡 막기 */
    const handleBallCapBlock = () => {
        setIsBallCapBlock(true)
    }

    /** 볼캡 치우기 */
    const handleBallCapRelease = () => {
        setIsBallCapBlock(false)
    }

    /** 캐쳐 회전 */
    const handleCatcherRotate = () => {
        const oriQut = catcherRef.current!.rotation()
        const oriEul = new THREE.Euler().setFromQuaternion(new THREE.Quaternion(oriQut.x, oriQut.y, oriQut.z, oriQut.w))
        console.log(oriEul)
        const rot = {
            x: oriEul.x,
            y: oriEul.y,
            z: oriEul.z
        }
        
        gsap.to(rot, {
            duration: 2, z: `+=${Math.PI/2}`,  ease: 'power1.inOut',
            onUpdate: () => {
                const rotation = new THREE.Quaternion().setFromEuler(new THREE.Euler(rot.x, rot.y, rot.z))
                catcherRef.current?.setRotation(rotation, true);
            }
        })
    }

    /** 당첨볼 결과가이더로 보내기 */
    const handleWinnerBallExtract = () => {
        SetWinnerBallExtractor((prev) => !prev)
    }

    return (
        <>
            <RigidBody
                type='fixed'
            >
                <BallCollider
                    args={ [ 0.1 ] }
                    position={ [ 0, 1.22, 0 ] }
                    sensor
                    onIntersectionEnter={ handleBallCapBlock }
                />
            </RigidBody>
            {
                isBallBlock && 
                <RigidBody
                    ref={ upperCapRef }
                    type='kinematicPosition'
                    colliders='trimesh'
                    ccd={true}
                    position={ [ 0, 0, 0 ] }
                >
                    <mesh
                    geometry={nodes.BallCaseUpperCap.geometry}
                    material={nodes.BallCaseUpperCap.material}
                    />
                </RigidBody>
            }
            <RigidBody
                ref={ catcherRef }
                type='kinematicPosition'
                colliders='trimesh'
                ccd={true}
            >
                <mesh
                    geometry={nodes.BallCatcher1.geometry}
                    material={nodes.BallCatcher1.material}
                    position={[0, 1.1, 0]}
                    rotation={[Math.PI / 2, 0, 0]}
                    scale={[0.15, 0.3, 0.15]}
                />
            
                <mesh
                    geometry={nodes.BallCatcher2.geometry}
                    material={nodes.BallCatcher2.material}
                    position={[1.1, 0, 0]}
                    rotation={[Math.PI / 2, -Math.PI / 2, 0]}
                    scale={[0.15, 0.3, 0.15]}
                />
                <mesh
                    geometry={nodes.BallCatcher3.geometry}
                    material={nodes.BallCatcher3.material}
                    position={[0, -1.1, 0]}
                    rotation={[-Math.PI / 2, 0, Math.PI]}
                    scale={[0.15, 0.3, 0.15]}
                />
                <mesh
                    geometry={nodes.BallCatcher4.geometry}
                    material={nodes.BallCatcher4.material}
                    position={[-1.1, 0, 0]}
                    rotation={[Math.PI / 2, Math.PI / 2, 0]}
                    scale={[0.15, 0.3, 0.15]}
                />
            </RigidBody>

            {
                isWinnerBallExtractor &&
                <RigidBody
                    type='fixed'
                    sensor
                    onIntersectionEnter={(payload) => {
                        payload.other.rigidBody?.applyImpulse({ x: 0, y: 0, z: -0.003 }, true)
                    }}
                >
                    <CylinderCollider
                        args={ [ 0.2, 0.1 ] }
                        position={ [ 0, -1.1, 0 ] }
                        rotation={ [ Math.PI / 2, 0, 0 ] }
                    />
                </RigidBody>
            }
            

            <RigidBody
                type='fixed'
                colliders='trimesh'
            >
                <mesh
                    geometry={nodes.BallCatcherGuider1.geometry}
                    material={nodes.BallCatcherGuider1.material}
                    position={[0, 0, -0.16]}
                    rotation={[Math.PI / 2, 0, 0]}
                    scale={1.5}
                />
                <mesh
                    geometry={nodes.BallCatcherGuider2.geometry}
                    material={nodes.BallCatcherGuider2.material}
                    position={[0, 0, 0.16]}
                    rotation={[Math.PI / 2, 0, 0]}
                    scale={1.5}
                />
            </RigidBody>
        </>
    )
}

/** 공 통 */
const BallCase = ({ gltf } : { gltf: GLTFResult }) => {
    const { nodes } = gltf;
    const [isMixer1, setIsMixer1] = useState(false);
    const [isMixer2, setIsMixer2] = useState(false);
    

    useControls('machaine', {
        isMixer1: {
            value: false,
            onChange: (value) => {
                if (value)
                    handleMixer1Start()
                else
                    handleMixer1Stop()
            }
        },
        isMixer2: {
            value: false,
            onChange: (value) => {
                if (value)
                    handleMixer2Start()
                else
                    handleMixer2Stop()
            }
        },
    })

    /** 1차 믹서 가동 */
    const handleMixer1Start = () => {
        setIsMixer1(true)
    }

    /** 1차 믹서 중단 */
    const handleMixer1Stop = () => {
        setIsMixer1(false)
    }

    /** 2차 믹서 가동 */
    const handleMixer2Start = () => {
        setIsMixer2(true)
    }

    /** 2차 믹서 중단 */
    const handleMixer2Stop = () => {
        setIsMixer2(false)
    }
    return (
        <>
           
            <RigidBody
                type='fixed'
                colliders='trimesh'
            >
                <mesh geometry={nodes.BallCase.geometry} material={nodes.BallCase.material} />
            </RigidBody>


            {
                isMixer1 &&
                <RigidBody
                    type="fixed"
                    position={ [ 0, -0.6, 0 ] }
                    rotation={ [ 0, 0, Math.PI ] }
                >
                    <ConeCollider
                        args={ [ 0.4, 0.6 ] }
                        sensor
                        onIntersectionEnter={(payload) => {
                                payload.other.rigidBody?.applyImpulse({ x: 0, y: 0.02, z: 0 }, true)
                                if(!payload.other.rigidBody?.isCcdEnabled()){
                                    payload.other.rigidBody?.enableCcd(true)
                                }
                        }}
                    />
                </RigidBody>
            }
            {
                isMixer2 &&
                <RigidBody
                    type="fixed"
                    position={ [ 0, -0.55, 0 ] }
                >
                    <CapsuleCollider
                        args={ [ 0.4, 0.3 ] }
                        sensor
                        onIntersectionEnter={(payload) => {
                                payload.other.rigidBody?.applyImpulse({ x: 0, y: 0.06, z: 0 }, true)
                                if(!payload.other.rigidBody?.isCcdEnabled()){
                                    payload.other.rigidBody?.enableCcd(true)
                                }
                        }}
                    />
                </RigidBody>
            }
        </>
    )
}

/** 공 주입기 */
const Injectors = ({ gltf } : { gltf: GLTFResult }) => {
    const { nodes } = gltf;
    const injectorCapRef = useRef<RapierRigidBody>(null);
    const injectorRef = useRef<RapierRigidBody>(null);

    useControls('machine', {
        isInjectorCapBlocked: {
            value: false,
            onChange: (value) => {
                if (value)
                    handleInjectorCapBlock()
                else 
                    handleInjectorCapRelease()
            }
        },
        isInjectorDown: {
            value: false,
            onChange: (value) => {
                if (value)
                    handleInJectorDown()
                else 
                    handleInejctorUp()
            }
        }
    })

    /** 인젝터 캡 막기 */
    const handleInjectorCapBlock = () => {
        const trs = injectorCapRef.current!.translation();
        const pos = {
            z: trs.z,
        }
        gsap.to(pos, { duration: 1, z: 0,  ease: 'power1.inOut', onUpdate: () => {
            injectorCapRef.current?.setTranslation({ x: 0, y: 0, z: pos.z }, true);
        }})
    }

    /** 인젝터 캡 치우기 */
    const handleInjectorCapRelease = () => {
        const trs = injectorCapRef.current!.translation();
        const pos = {
            z: trs.z,
        }
        gsap.to(pos, { duration: 1, z: 1,  ease: 'power1.inOut', onUpdate: () => {
            injectorCapRef.current?.setTranslation({ x: 0, y: 0, z: pos.z }, true);
        }})
    }

    /** 인젝터 내리기 */
    const handleInJectorDown = () => {
        const trs = injectorRef.current!.translation();
        const pos = {
            y: trs.y,
        }
        gsap.to(pos, { duration: 1, y: -1,  ease: 'power1.inOut', onUpdate: () => {
            injectorRef.current?.setTranslation({ x: 0, y: pos.y, z: 0 }, true);
        }})
    }

    /** 인젝터 올리기 */
    const handleInejctorUp = () => {
        const trs = injectorRef.current!.translation();
        const pos = {
            y: trs.y,
        }
        gsap.to(pos, { duration: 1, y: 0,  ease: 'power1.inOut', onUpdate: () => {
            injectorRef.current?.setTranslation({ x: 0, y: pos.y, z: 0 }, true);
        }})
    }
    
    return (
        <>
            <RigidBody
                ref={ injectorCapRef }
                type='kinematicPosition'
                colliders='trimesh'
                position={ [ 0, 0, 1 ] }
            >
                <mesh
                    geometry={nodes.BallCaseBallInjectorCap.geometry}
                    material={nodes.BallCaseBallInjectorCap.material}
                />
            </RigidBody>
            <RigidBody
                ref={ injectorRef }
                type='kinematicPosition'
                colliders='trimesh'
            >
                <mesh
                    geometry={nodes.BallInjector3.geometry}
                    material={nodes.BallInjector3.material}
                    position={[0.2, 1.15, 1.2]}
                    scale={[0.11, 1, 0.11]}
                />
                <mesh
                    geometry={nodes.BallInjector2.geometry}
                    material={nodes.BallInjector2.material}
                    position={[0.43, 1.16, 1.1]}
                    scale={[0.11, 1, 0.11]}
                />
                <mesh
                    geometry={nodes.BallInjecter1.geometry}
                    material={nodes.BallInjecter1.material}
                    position={[0.66, 1.19, 1]}
                    scale={[0.11, 1, 0.11]}
                />
                <mesh
                    geometry={nodes.BallInjector4.geometry}
                    material={nodes.BallInjector4.material}
                    position={[-0.2, 1.15, 1.2]}
                    scale={[0.11, 1, 0.11]}
                />
                <mesh
                    geometry={nodes.BallInjector5.geometry}
                    material={nodes.BallInjector5.material}
                    position={[-0.43, 1.16, 1.1]}
                    scale={[0.11, 1, 0.11]}
                />
                <mesh
                    geometry={nodes.BallInjector6.geometry}
                    material={nodes.BallInjector6.material}
                    position={[-0.66, 1.19, 1]}
                    scale={[0.11, 1, 0.11]}
                />
            </RigidBody>
        </>
    )
}

/** 당첨볼 결과대 */
const BallResult = ({ gltf }: { gltf: GLTFResult }) => {
    const { nodes } = gltf;
    return (
        <>
            <RigidBody
                type='fixed'
                colliders='trimesh'
            >
                <mesh
                geometry={nodes.ResultCase.geometry}
                material={nodes.ResultCase.material}
                position={[0, -1.65, -0.75]}
                rotation={[0, 0, -1.676]}
                scale={[0.12, 1, 0.12]}
                />
            </RigidBody>
            <RigidBody
                type='fixed'
                colliders='trimesh'
            >
                <mesh
                geometry={nodes.ResultGuider.geometry}
                material={nodes.ResultGuider.material}
                position={[1.434, -1.123, -0.288]}
                rotation={[-Math.PI / 9, Math.PI / 2, 0]}
                scale={[0.15, 0.15, 1]}
                />
            </RigidBody>
        </>
    )
}

/** 하단 지지대 */
const MainSupport = ({ gltf } : { gltf: GLTFResult }) => {
    const { nodes } = gltf;
    return (
        <>
            <mesh
                geometry={nodes.MainSupport.geometry}
                material={nodes.MainSupport.material}
                position={[0.027, -3.59, -0.003]}
                scale={[1, 1.7, 1]}
            />
        </>
    )
}